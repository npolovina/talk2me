# .github/workflows/deploy-k8s.yml
name: 2. Deploy to EKS

on:
  workflow_run:
    workflows: ["1. Build and Push Images"]
    types:
      - completed
    branches: [main]
  # Allow manual deployments
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Image tag to deploy (defaults to latest build)'
        required: false
        default: ''

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    permissions:
      id-token: write
      contents: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Download artifacts from the triggering workflow (only for workflow_run trigger)
      - name: Download artifacts from workflow
        if: ${{ github.event_name == 'workflow_run' && github.event.inputs.image_tag == '' }}
        uses: dawidd6/action-download-artifact@v2
        with:
          workflow: build.yml
          name: image-tag
          path: .
          workflow_conclusion: success
          
      # Configure AWS credentials
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}
          output-credentials: true

      # Verify AWS authentication
      - name: Verify AWS authentication
        run: |
          echo "Verifying AWS authentication:"
          aws sts get-caller-identity
          echo "AWS credentials successfully configured"

      # Install required tools
      - name: Install tools
        run: |
          # Install kubectl
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
          kubectl version --client
          
          # Install jq for JSON processing
          sudo apt-get update && sudo apt-get install -y jq

      # Get AWS account ID
      - name: Get AWS account ID
        id: aws-account
        run: |
          echo "account_id=$(aws sts get-caller-identity --query Account --output text)" >> $GITHUB_OUTPUT

      # Set image tag based on input or artifact
      - name: Set image tag
        id: vars
        run: |
          if [ -n "${{ github.event.inputs.image_tag }}" ]; then
            echo "image_tag=${{ github.event.inputs.image_tag }}" >> $GITHUB_OUTPUT
          elif [ -f "image_tag.txt" ]; then
            IMAGE_TAG=$(cat image_tag.txt)
            echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          else
            # Fallback to 'latest' if no tag is available
            echo "image_tag=latest" >> $GITHUB_OUTPUT
            echo "Warning: No image tag found, using 'latest' instead" >> $GITHUB_STEP_SUMMARY
          fi

      # Configure access to EKS cluster with proper authentication
      - name: Configure EKS access
        run: |
          echo "Setting up kubectl configuration for EKS cluster ${{ secrets.EKS_CLUSTER_NAME }}"
          
          # Get AWS identity for debugging
          echo "Current AWS identity:"
          aws sts get-caller-identity
          
          # Get cluster endpoint and CA certificate
          CLUSTER_ENDPOINT=$(aws eks describe-cluster --name ${{ secrets.EKS_CLUSTER_NAME }} --region ${{ secrets.AWS_REGION }} --query "cluster.endpoint" --output text)
          CLUSTER_CA=$(aws eks describe-cluster --name ${{ secrets.EKS_CLUSTER_NAME }} --region ${{ secrets.AWS_REGION }} --query "cluster.certificateAuthority.data" --output text)
          
          # Create kubeconfig manually with token authentication
          cat > kubeconfig << EOF
          apiVersion: v1
          clusters:
          - cluster:
              server: ${CLUSTER_ENDPOINT}
              certificate-authority-data: ${CLUSTER_CA}
            name: eks-cluster
          contexts:
          - context:
              cluster: eks-cluster
              user: eks-user
            name: eks-context
          current-context: eks-context
          kind: Config
          preferences: {}
          users:
          - name: eks-user
            user:
              exec:
                apiVersion: client.authentication.k8s.io/v1beta1
                command: aws
                args:
                  - eks
                  - get-token
                  - --cluster-name
                  - ${{ secrets.EKS_CLUSTER_NAME }}
                  - --region
                  - ${{ secrets.AWS_REGION }}
          EOF
          
          # Set KUBECONFIG environment variable
          echo "KUBECONFIG=$(pwd)/kubeconfig" >> $GITHUB_ENV
          
          # Test connection with retry logic
          for i in {1..3}; do
            echo "Attempt $i: Testing connection to EKS cluster..."
            if kubectl get nodes; then
              echo "✅ Successfully connected to EKS cluster!"
              break
            else
              if [ $i -eq 3 ]; then
                echo "❌ Failed to connect to EKS cluster after 3 attempts"
                exit 1
              fi
              echo "Retrying in 5 seconds..."
              sleep 5
            fi
          done

      # Create namespace if it doesn't exist
      - name: Create namespace if needed
        run: |
          echo "Ensuring talk2me namespace exists..."
          kubectl create namespace talk2me --dry-run=client -o yaml | kubectl apply -f -

      # Update Kubernetes secrets
      - name: Update Kubernetes secrets
        run: |
          echo "Creating Kubernetes secret..."
          DEEPSEEK_API_KEY_BASE64=$(echo -n "${{ secrets.DEEPSEEK_API_KEY }}" | base64 -w 0)
          
          # Create secret configuration
          cat << EOF > ./secret.yaml
          apiVersion: v1
          kind: Secret
          metadata:
            name: talk2me-secrets
            namespace: talk2me
          type: Opaque
          data:
            deepseek-api-key: ${DEEPSEEK_API_KEY_BASE64}
          EOF
          
          # Apply the secret
          kubectl apply -f ./secret.yaml
          
          # Verify secret was created
          kubectl get secrets -n talk2me
          
          # Clean up
          rm ./secret.yaml

      # Process and apply Kubernetes manifests
      - name: Deploy to EKS
        run: |
          echo "Deploying Kubernetes manifests..."
          # Set variables for templating
          export AWS_ACCOUNT_ID="${{ steps.aws-account.outputs.account_id }}"
          export AWS_REGION="${{ secrets.AWS_REGION }}"
          export IMAGE_TAG="${{ steps.vars.outputs.image_tag }}"
          
          # Process the manifests
          for manifest in k8s/*.yaml; do
            echo "Processing $manifest..."
            envsubst < "$manifest" > processed_manifest.yaml
            kubectl apply -f processed_manifest.yaml
            rm processed_manifest.yaml
          done

      # Verify deployment with timeouts and error handling
      - name: Verify deployment
        run: |
          echo "Verifying backend deployment..."
          kubectl rollout status deployment/talk2me-backend -n talk2me --timeout=120s || echo "Backend deployment verification timed out, but continuing..."
          
          echo "Verifying frontend deployment..."
          kubectl rollout status deployment/talk2me-frontend -n talk2me --timeout=120s || echo "Frontend deployment verification timed out, but continuing..."
          
          echo "Listing all resources in the talk2me namespace:"
          kubectl get all -n talk2me