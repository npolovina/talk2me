# .github/workflows/deploy.yml
name: 3. Deploy to K8s

on:
  workflow_run:
    workflows: ["2. Build and Push Images"]
    types:
      - completed
    branches: [main]
  # Allow manual deployments
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Image tag to deploy (defaults to latest build)'
        required: false
        default: ''
      namespace:
        description: 'Kubernetes namespace to deploy to'
        required: false
        default: 'talk2me'
      run_verification:
        description: 'Run verification workflow after deployment'
        required: false
        default: 'true'
        type: boolean

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    permissions:
      id-token: write  # Required for OIDC auth
      contents: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Download artifacts from the triggering workflow (only for workflow_run trigger)
      - name: Download artifacts from workflow
        if: ${{ github.event_name == 'workflow_run' }}
        uses: dawidd6/action-download-artifact@v2
        with:
          workflow: build.yml
          name: deployment-info
          path: ./deployment-info
          workflow_conclusion: success
          
      # Configure AWS credentials
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}
          mask-aws-account-id: false # Show account ID for better debugging

      # Verify AWS authentication
      - name: Verify AWS authentication
        run: |
          echo "Verifying AWS authentication:"
          aws sts get-caller-identity
          echo "AWS credentials successfully configured"
          
          # Also check ECR access
          echo "Verifying ECR access:"
          aws ecr get-authorization-token --region ${{ secrets.AWS_REGION }}
          echo "ECR access verified"

      # Install kubectl
      - name: Install kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      # Get AWS account ID
      - name: Get AWS account ID
        id: aws-account
        run: |
          echo "account_id=$(aws sts get-caller-identity --query Account --output text)" >> $GITHUB_OUTPUT

      # Set image tag based on input or artifact
      - name: Set image tag
        id: vars
        run: |
          # Set namespace
          if [ -n "${{ github.event.inputs.namespace }}" ]; then
            NAMESPACE="${{ github.event.inputs.namespace }}"
          else
            NAMESPACE="talk2me"
          fi
          echo "namespace=${NAMESPACE}" >> $GITHUB_OUTPUT
          
          # Set image tag
          if [ -n "${{ github.event.inputs.image_tag }}" ]; then
            echo "image_tag=${{ github.event.inputs.image_tag }}" >> $GITHUB_OUTPUT
            echo "Using manually specified image tag: ${{ github.event.inputs.image_tag }}"
          elif [ -f "./deployment-info/image_tag.txt" ]; then
            IMAGE_TAG=$(cat ./deployment-info/image_tag.txt)
            echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
            echo "Using image tag from build workflow: ${IMAGE_TAG}"
            if [ -f "./deployment-info/build_time.txt" ]; then
              BUILD_TIME=$(cat ./deployment-info/build_time.txt)
              echo "Image was built at: ${BUILD_TIME}"
            fi
            if [ -f "./deployment-info/registry.txt" ]; then
              REGISTRY=$(cat ./deployment-info/registry.txt)
              echo "registry=${REGISTRY}" >> $GITHUB_OUTPUT
            fi
          else
            # Fallback to 'latest' if no tag is available
            echo "image_tag=latest" >> $GITHUB_OUTPUT
            echo "Warning: No image tag found, using 'latest' instead"
          fi

      # Update kubeconfig to connect to EKS cluster
      - name: Update kubeconfig for EKS cluster
        run: |
          if [ -z "${{ secrets.EKS_CLUSTER_NAME }}" ]; then
            echo "Error: EKS_CLUSTER_NAME secret is not set"
            exit 1
          fi
          
          # Get current role identity for debugging
          echo "Current AWS identity:"
          aws sts get-caller-identity
          
          # Describe EKS cluster to verify access
          echo "Verifying access to EKS cluster ${{ secrets.EKS_CLUSTER_NAME }}:"
          aws eks describe-cluster --name ${{ secrets.EKS_CLUSTER_NAME }} --region ${{ secrets.AWS_REGION }} --query "cluster.name"
          
          # Update kubeconfig
          echo "Updating kubeconfig for EKS cluster ${{ secrets.EKS_CLUSTER_NAME }}..."
          aws eks update-kubeconfig --region ${{ secrets.AWS_REGION }} \
            --name ${{ secrets.EKS_CLUSTER_NAME }}
          
          # Test access to the cluster
          echo "Testing access to Kubernetes cluster:"
          kubectl cluster-info
          kubectl get nodes

      # Create namespace if it doesn't exist
      - name: Ensure namespace exists
        run: |
          echo "Creating namespace ${{ steps.vars.outputs.namespace }} if it doesn't exist..."
          kubectl create namespace ${{ steps.vars.outputs.namespace }} --dry-run=client -o yaml | kubectl apply -f -

      # Update Kubernetes secrets
      - name: Update Kubernetes secrets
        run: |
          echo "Creating Kubernetes secret..."
          DEEPSEEK_API_KEY_BASE64=$(echo -n "${{ secrets.DEEPSEEK_API_KEY }}" | base64 -w 0)
          
          # Create secret configuration
          cat << EOF > ./secret.yaml
          apiVersion: v1
          kind: Secret
          metadata:
            name: talk2me-secrets
            namespace: ${{ steps.vars.outputs.namespace }}
          type: Opaque
          data:
            deepseek-api-key: ${DEEPSEEK_API_KEY_BASE64}
          EOF
          
          # Apply the secret
          kubectl apply -f ./secret.yaml
          rm ./secret.yaml

      # Process and apply Kubernetes manifests
      - name: Deploy to EKS
        run: |
          echo "Deploying Kubernetes manifests..."
          # Set variables for templating
          export AWS_ACCOUNT_ID="${{ steps.aws-account.outputs.account_id }}"
          export AWS_REGION="${{ secrets.AWS_REGION }}"
          export IMAGE_TAG="${{ steps.vars.outputs.image_tag }}"
          export NAMESPACE="${{ steps.vars.outputs.namespace }}"
          export REGISTRY="${{ steps.vars.outputs.registry || format('{0}.dkr.ecr.{1}.amazonaws.com', steps.aws-account.outputs.account_id, secrets.AWS_REGION) }}"
          
          # Create deployments directory if it doesn't exist
          mkdir -p deployments
          
          # Generate backend deployment
          cat << EOF > deployments/backend-deployment.yaml
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: talk2me-backend
            namespace: ${NAMESPACE}
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: talk2me-backend
            template:
              metadata:
                labels:
                  app: talk2me-backend
              spec:
                containers:
                - name: backend
                  image: ${REGISTRY}/talk2me-backend:${IMAGE_TAG}
                  ports:
                  - containerPort: 8000
                  env:
                  - name: DEEPSEEK_API_KEY
                    valueFrom:
                      secretKeyRef:
                        name: talk2me-secrets
                        key: deepseek-api-key
                  resources:
                    limits:
                      cpu: "500m"
                      memory: "512Mi"
                    requests:
                      cpu: "250m"
                      memory: "256Mi"
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: talk2me-backend
            namespace: ${NAMESPACE}
          spec:
            selector:
              app: talk2me-backend
            ports:
            - port: 80
              targetPort: 80
            type: ClusterIP
          EOF
          
          # Generate ingress configuration
          cat << EOF > deployments/ingress.yaml
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: talk2me-ingress
            namespace: ${NAMESPACE}
            annotations:
              kubernetes.io/ingress.class: "alb"
              alb.ingress.kubernetes.io/scheme: internet-facing
              alb.ingress.kubernetes.io/target-type: ip
              alb.ingress.kubernetes.io/listen-ports: '[{"HTTP": 80}, {"HTTPS": 443}]'
              alb.ingress.kubernetes.io/ssl-redirect: '443'
              alb.ingress.kubernetes.io/certificate-arn: "${{ secrets.CERTIFICATE_ARN }}"
              alb.ingress.kubernetes.io/ssl-policy: "ELBSecurityPolicy-TLS-1-2-2017-01"
              external-dns.alpha.kubernetes.io/hostname: "talk2me-gen-z.com,api.talk2me-gen-z.com"
          spec:
            rules:
            - host: talk2me-gen-z.com
              http:
                paths:
                - path: /
                  pathType: Prefix
                  backend:
                    service:
                      name: talk2me-frontend
                      port:
                        number: 80
            - host: api.talk2me-gen-z.com
              http:
                paths:
                - path: /
                  pathType: Prefix
                  backend:
                    service:
                      name: talk2me-backend
                      port:
                        number: 80
          EOF
          
          # Apply all deployment manifests
          kubectl apply -f deployments/backend-deployment.yaml
          kubectl apply -f deployments/frontend-deployment.yaml
          kubectl apply -f deployments/ingress.yaml
          
          # List all applied resources
          echo "Deployed resources in namespace ${{ steps.vars.outputs.namespace }}:"
          kubectl get all -n ${{ steps.vars.outputs.namespace }}

      # Verify deployment with timeouts and error handling
      - name: Verify deployment
        run: |
          echo "Verifying backend deployment..."
          kubectl rollout status deployment/talk2me-backend -n ${{ steps.vars.outputs.namespace }} --timeout=180s || {
            echo "Warning: Backend deployment verification timed out"
            echo "Current pods status:"
            kubectl get pods -n ${{ steps.vars.outputs.namespace }} -l app=talk2me-backend -o wide
            echo "Recent pod events:"
            kubectl get events -n ${{ steps.vars.outputs.namespace }} --sort-by='.lastTimestamp' | grep backend || true
          }
          
          echo "Verifying frontend deployment..."
          kubectl rollout status deployment/talk2me-frontend -n ${{ steps.vars.outputs.namespace }} --timeout=180s || {
            echo "Warning: Frontend deployment verification timed out"
            echo "Current pods status:"
            kubectl get pods -n ${{ steps.vars.outputs.namespace }} -l app=talk2me-frontend -o wide
            echo "Recent pod events:"
            kubectl get events -n ${{ steps.vars.outputs.namespace }} --sort-by='.lastTimestamp' | grep frontend || true
          }

      # Get service details
      - name: Get service information
        run: |
          echo "Service information for namespace ${{ steps.vars.outputs.namespace }}:"
          kubectl get services -n ${{ steps.vars.outputs.namespace }}
          
          # Check if ingress is available
          if kubectl get ingress -n ${{ steps.vars.outputs.namespace }} &>/dev/null; then
            echo "Ingress information:"
            kubectl get ingress -n ${{ steps.vars.outputs.namespace }}
            echo "Application should be accessible via the above ingress address"
          else
            echo "No ingress found. The application may be accessible via ClusterIP or LoadBalancer services."
          fi
          
          echo "Deployment completed at $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          
      # Save deployment results
      - name: Save deployment results
        run: |
          # Create deployment summary
          cat << EOF > deployment-summary.md
          # Deployment Summary
          
          ## Details
          - Namespace: ${{ steps.vars.outputs.namespace }}
          - Image Tag: ${{ steps.vars.outputs.image_tag }}
          - Deployed At: $(date -u +'%Y-%m-%d %H:%M:%S UTC')
          
          ## Resources
          \`\`\`
          $(kubectl get pods,svc,ingress -n ${{ steps.vars.outputs.namespace }})
          \`\`\`
          
          ## Access Information
          - Frontend URL: https://talk2me-gen-z.com
          - API URL: https://api.talk2me-gen-z.com
          
          ## Deployment Status
          - Backend: $(kubectl get deployment talk2me-backend -n ${{ steps.vars.outputs.namespace }} -o jsonpath='{.status.conditions[?(@.type=="Available")].status}' 2>/dev/null || echo "Unknown")
          - Frontend: $(kubectl get deployment talk2me-frontend -n ${{ steps.vars.outputs.namespace }} -o jsonpath='{.status.conditions[?(@.type=="Available")].status}' 2>/dev/null || echo "Unknown")
          EOF

      - name: Upload deployment results
        uses: actions/upload-artifact@v4
        with:
          name: deployment-results
          path: deployment-summary.md
          retention-days: 7
          
      # Trigger verification workflow if requested
      - name: Trigger verification workflow
        if: ${{ github.event.inputs.run_verification != 'false' }}
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'verify.yml',
              ref: '${{ github.ref_name }}',
              inputs: {
                namespace: '${{ steps.vars.outputs.namespace }}'
              }
            });
            console.log('Verification workflow triggered');