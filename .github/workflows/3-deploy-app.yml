name: 3. Deploy Application to EKS

on:
  workflow_dispatch:
    inputs:
      region:
        description: 'AWS Region'
        required: true
        default: 'us-east-1'
      cluster_name:
        description: 'EKS Cluster Name'
        required: true
        default: 'talk2me-cluster'
      image_tag:
        description: 'Docker Image Tag (must exist in ECR)'
        required: true
        default: 'latest'
      build_run_id:
        description: 'Build workflow run ID (optional)'
        required: false

env:
  AWS_REGION: ${{ github.event.inputs.region }}
  CLUSTER_NAME: ${{ github.event.inputs.cluster_name }}
  IMAGE_TAG: ${{ github.event.inputs.image_tag }}
  BACKEND_ECR_REPOSITORY: talk2me-backend
  FRONTEND_ECR_REPOSITORY: talk2me-frontend
  ALB_NAME: talk2me-alb

permissions:
  id-token: write
  contents: read
  actions: read

jobs:
  setup:
    runs-on: ubuntu-latest
    outputs:
      aws_account_id: ${{ steps.get-aws-account.outputs.account_id }}
    steps:
      - uses: actions/checkout@v3

      - uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - id: get-aws-account
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "account_id=$AWS_ACCOUNT_ID" >> $GITHUB_OUTPUT

  get-artifacts:
    needs: setup
    if: github.event.inputs.build_run_id != ''
    runs-on: ubuntu-latest
    steps:
      - run: |
          mkdir -p ./artifacts
          gh api \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            /repos/${{ github.repository }}/actions/runs/${{ github.event.inputs.build_run_id }}/artifacts > artifacts_list.json

          IMAGE_INFO_ARTIFACT_ID=$(jq '.artifacts[] | select(.name=="image-info") | .id' artifacts_list.json)

          if [ -z "$IMAGE_INFO_ARTIFACT_ID" ]; then
            echo "Could not find image-info artifact"
            exit 1
          fi

          gh api \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            /repos/${{ github.repository }}/actions/artifacts/$IMAGE_INFO_ARTIFACT_ID/zip -o artifact.zip

          unzip artifact.zip -d ./artifacts

          if [ -f "./artifacts/image-info.env" ]; then
            cat ./artifacts/image-info.env >> $GITHUB_ENV
          else
            echo "Artifact not found"
            exit 1
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  configure-images:
    needs: [setup, get-artifacts]
    runs-on: ubuntu-latest
    steps:
      - run: |
          if [ -z "$BACKEND_IMAGE" ] || [ -z "$FRONTEND_IMAGE" ]; then
            ECR_REGISTRY=${{ needs.setup.outputs.aws_account_id }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com
            BACKEND_IMAGE=$ECR_REGISTRY/$BACKEND_ECR_REPOSITORY:$IMAGE_TAG
            FRONTEND_IMAGE=$ECR_REGISTRY/$FRONTEND_ECR_REPOSITORY:$IMAGE_TAG
            echo "BACKEND_IMAGE=$BACKEND_IMAGE" >> $GITHUB_ENV
            echo "FRONTEND_IMAGE=$FRONTEND_IMAGE" >> $GITHUB_ENV
          fi

  deploy-manifests:
    needs: configure-images
    runs-on: ubuntu-latest
    steps:
      - run: aws eks update-kubeconfig --region $AWS_REGION --name $CLUSTER_NAME

      - uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - run: |
          kubectl get namespace talk2me || kubectl create namespace talk2me

          # Backend deployment
          cat <<EOF | kubectl apply -f -
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: talk2me-backend
            namespace: talk2me
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: talk2me-backend
            template:
              metadata:
                labels:
                  app: talk2me-backend
              spec:
                containers:
                - name: backend
                  image: $BACKEND_IMAGE
                  ports:
                  - containerPort: 8080
                  resources:
                    limits:
                      cpu: "1"
                      memory: "1Gi"
                    requests:
                      cpu: "0.5"
                      memory: "512Mi"
          EOF

          # Backend service
          cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: Service
          metadata:
            name: talk2me-backend
            namespace: talk2me
          spec:
            selector:
              app: talk2me-backend
            ports:
            - port: 80
              targetPort: 8080
            type: ClusterIP
          EOF

          # Frontend deployment
          cat <<EOF | kubectl apply -f -
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: talk2me-frontend
            namespace: talk2me
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: talk2me-frontend
            template:
              metadata:
                labels:
                  app: talk2me-frontend
              spec:
                containers:
                - name: frontend
                  image: $FRONTEND_IMAGE
                  ports:
                  - containerPort: 80
                  resources:
                    limits:
                      cpu: "0.5"
                      memory: "512Mi"
                    requests:
                      cpu: "0.25"
                      memory: "256Mi"
          EOF

          # Frontend service
          cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: Service
          metadata:
            name: talk2me-frontend
            namespace: talk2me
          spec:
            selector:
              app: talk2me-frontend
            ports:
            - port: 80
              targetPort: 80
            type: ClusterIP
          EOF

          # Ingress
          cat <<EOF | kubectl apply -f -
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: talk2me-ingress
            namespace: talk2me
            annotations:
              kubernetes.io/ingress.class: alb
              alb.ingress.kubernetes.io/scheme: internet-facing
              alb.ingress.kubernetes.io/target-type: ip
              alb.ingress.kubernetes.io/load-balancer-name: ${ALB_NAME}
          spec:
            rules:
            - http:
                paths:
                - path: /api
                  pathType: Prefix
                  backend:
                    service:
                      name: talk2me-backend
                      port:
                        number: 80
                - path: /
                  pathType: Prefix
                  backend:
                    service:
                      name: talk2me-frontend
                      port:
                        number: 80
          EOF

  verify:
    needs: deploy-manifests
    runs-on: ubuntu-latest
    steps:
      - run: |
          kubectl rollout status deployment/talk2me-backend -n talk2me --timeout=300s
          kubectl rollout status deployment/talk2me-frontend -n talk2me --timeout=300s

          kubectl get pods -n talk2me
          kubectl get svc -n talk2me
          kubectl get ingress -n talk2me

          ALB_DNS=$(kubectl get ingress talk2me-ingress -n talk2me -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          echo "ALB_DNS=$ALB_DNS" >> $GITHUB_ENV

  notify:
    needs: verify
    runs-on: ubuntu-latest
    steps:
      - run: |
          if [ -n "$ALB_DNS" ]; then
            echo "::notice::Application deployed at: http://$ALB_DNS"
          else
            echo "::notice::App deployed. ALB DNS not available yet. Check AWS Console."
